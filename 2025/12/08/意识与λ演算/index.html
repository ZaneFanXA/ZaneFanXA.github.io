<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 8.1.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="前言 本文的灵感来源于我对《哥德尔、埃舍尔、巴赫：集异璧之大成》核心观点的探索。虽然尚未通读原著，但在通过AI梳理其脉络时，书中关于“自指”与“怪圈”的概念引发了我对λ演算的强烈共鸣。 λ演算 什么是λ演算 λ演算是图灵的博士导师丘奇所创造的用于研究计算理论的工具，理论上和图灵机是完全等价的，至今你还可以在现代程序语言的匿名函数里看到它的影子。 λ演算的基本元素是λ表达式。我们用符号M来">
<meta property="og:type" content="article">
<meta property="og:title" content="意识与λ演算">
<meta property="og:url" content="http://example.com/2025/12/08/%E6%84%8F%E8%AF%86%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/index.html">
<meta property="og:site_name" content="妄心随记">
<meta property="og:description" content="前言 本文的灵感来源于我对《哥德尔、埃舍尔、巴赫：集异璧之大成》核心观点的探索。虽然尚未通读原著，但在通过AI梳理其脉络时，书中关于“自指”与“怪圈”的概念引发了我对λ演算的强烈共鸣。 λ演算 什么是λ演算 λ演算是图灵的博士导师丘奇所创造的用于研究计算理论的工具，理论上和图灵机是完全等价的，至今你还可以在现代程序语言的匿名函数里看到它的影子。 λ演算的基本元素是λ表达式。我们用符号M来">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2025-12-08T02:36:39.000Z">
<meta property="article:modified_time" content="2025-12-08T09:50:49.390Z">
<meta property="article:author" content="Zane.F">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/2025/12/08/%E6%84%8F%E8%AF%86%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>意识与λ演算 | 妄心随记</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">妄心随记</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2025/12/08/%E6%84%8F%E8%AF%86%E4%B8%8E%CE%BB%E6%BC%94%E7%AE%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Zane.F">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="妄心随记">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          意识与λ演算
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2025-12-08 10:36:39 / 修改时间：17:50:49" itemprop="dateCreated datePublished" datetime="2025-12-08T10:36:39+08:00">2025-12-08</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="前言">前言</h2>
<p>本文的灵感来源于我对《哥德尔、埃舍尔、巴赫：集异璧之大成》核心观点的探索。虽然尚未通读原著，但在通过AI梳理其脉络时，书中关于“自指”与“怪圈”的概念引发了我对λ演算的强烈共鸣。</p>
<h2 id="λ演算">λ演算</h2>
<h3 id="什么是λ演算">什么是λ演算</h3>
<p>λ演算是图灵的博士导师丘奇所创造的用于研究计算理论的工具，理论上和图灵机是完全等价的，至今你还可以在现代程序语言的匿名函数里看到它的影子。</p>
<p>λ演算的基本元素是λ表达式。我们用符号<span
class="math inline"><em>M</em></span>来代表一个λ表达式：</p>
<p><span class="math display">$$
\begin{aligned}
  M &amp;= X \\
  &amp;\quad | \; (\lambda \; (X) \; M) \\
  &amp;\quad | \; (M_1 \; M_2) \\
  X &amp;= \text{a variable: } x, y, \dots
\end{aligned}
$$</span></p>
<p>（为了方便理解，我们这里没有使用经典的表达形式即<span
class="math inline"><em>λ</em><em>X</em>.<em>M</em></span>，而是采用了现代Lisp语言的语法）</p>
<p>看到这里你可能有些困惑，一个东西的定义怎么能包括它自己的定义呢？实际上这是完全可以的，比如我们可以这样定义自然数<code>N</code>：</p>
<p><span class="math display">$$
\begin{aligned}
  N &amp;= 0 \\
  &amp;\quad | \; N+1 \\
\end{aligned}
$$</span></p>
<p>λ演算的表达式定义和这个很相似，下面是一些表达式的示例：</p>
<p><span class="math display">$$
\begin{aligned}
  &amp;x\\
  &amp;(\lambda \; (x) \; y)\\
  &amp;((\lambda \; (x) \; y) \; z)\\
  &amp;(x \; (\lambda \; (x) \; y))
\end{aligned}
$$</span></p>
<h3 id="λ演算推演规则">λ演算推演规则</h3>
<p>有了上一节的定义还不够，现在我们的世界里只有三种死气沉沉的基本粒子。我们还需要给这个世界添加一些物理法则，让这个世界活跃起来。</p>
<p>首先，我们用符号<span
class="math inline"><em>F</em><em>V</em></span>来表示一个λ表达式中的自由变量：</p>
<p><span class="math display">$$
\begin{aligned}
  FV(X) \quad &amp;= \quad \{X\}\\
  FV((\lambda \; (X) \; M)) \quad &amp;= \quad FV\{M\} \setminus
FV\{X\}\\
  FV((M_1 \; M_2)) \quad &amp;= \quad FV\{M_1\} \cup FV\{M_2\}
\end{aligned}
$$</span></p>
<p>有了<span
class="math inline"><em>F</em><em>V</em></span>后，我们可以给出一套符号替换法则，形式为<span
class="math inline"><em>M</em><sub>1</sub>[<em>X</em> ← <em>M</em><sub>2</sub>]</span>，即将<span
class="math inline"><em>M</em><sub>1</sub></span>中的符号<span
class="math inline"><em>X</em></span>替换为<span
class="math inline"><em>M</em><sub>2</sub></span>。具体法则如下：</p>
<p><span class="math display">$$
\begin{aligned}
  X_1[X_1 \gets M] \quad &amp;= \quad M\\
  X_2[X_1 \gets M] \quad &amp;= \quad X_2 \\
  &amp; \text{where} \; X_1 \ne X_2 \\
  (\lambda \; (X_1) \; M_1)[X_1 \gets M_2] \quad &amp;= \quad (\lambda
\; (X_1) \; M_1)\\
  (\lambda \; (X_1) \; M_1)[X_2 \gets M_2] \quad &amp;= \quad (\lambda
\; (X_3) \; M_1[X_1 \gets X_3][X_2 \gets M_2])\\
  &amp; \text{where} \; X_1 \ne X_2, X_3 \notin FV(M_2)\\
  &amp; \text{and} \; X_3 \notin FV(M_1)\setminus\{X_1\}\\
  (M_1 \; M_2)[X \gets M_3] \quad &amp;= \quad (M_1[X \gets M_3] \;
M_2[X \gets M_3])
\end{aligned}
$$</span></p>
<p>这里的一大堆规则核心只有一件事：确保我们在替换变量时，不会意外地改变其他变量的含义。最后，我们给出三条表达式推演规则：</p>
<p><span class="math display">$$
\begin{aligned}
  (\lambda \; (X_1) \; M) \quad &amp;\alpha \quad (\lambda \; (X_2) \;
M[X_1 \gets X_2]) \\
  &amp; \text{where} \; X_2 \notin FV(M)\\
  ((\lambda \; (X_1) \; M_1) \; M_2) \quad &amp;\beta \quad M_1[X \gets
M_2]\\
  (\lambda \; (X) \; (M \; X)) \quad &amp;\eta \quad M
\end{aligned}
$$</span></p>
<p>有了这三条规则，至此我们可以说，我们构建了一个最小形式的世界，里面有静态有动态。</p>
<h2 id="所谓意识">所谓意识</h2>
<h3 id="同构与解释">同构与解释</h3>
<p>当我们直接面对现实世界时，得到的只有一堆无意义的信息。眼前有五颜六色的光，耳朵能听到乱七八糟的声音。那么我们是如何从这对无意义的东西里生生找出来“意义”的呢？侯世达认为，当这些符号（比如颜色、声音等）和现实世界的事物产生了映射关系，意义就涌现了。</p>
<p>为了便于理解，我们结合λ演算来说明这个观点。首先为了方便，我们规定以下的便捷记法：</p>
<p><span class="math display">$$
\begin{aligned}
(\lambda \; (X_1 \; X_2 \dots) \; M) \quad &amp;= \quad (\lambda \;
(X_1) \;(\lambda \; (X_2) \; (\lambda \; (\dots) \; M)) \\
(M \; N \; L \dots) \quad &amp;= \quad (((M \; N) \; L) \; \dots)
\end{aligned}
$$</span></p>
<p>布尔值是所有编程语言都要实现的功能，在λ演算中我们定义和布尔值相关的符号如下：</p>
<p><span class="math display">$$
\begin{aligned}
  \text{true} \quad &amp;= \quad (\lambda \; (x \; y) \; x)  \\
  \text{false} \quad &amp;= \quad (\lambda \; (x \; y) \; y) \\
  \text{if} \quad &amp;= \quad (\lambda \; (v \; t \; f) \; (v \; t \;
f))
\end{aligned}
$$</span></p>
<p>不难看出，使用上一节定义的推演规则可以推导出如下规律：</p>
<p><span class="math display">$$
\begin{aligned}
  (\text{if} \; \text{true} \; M \; N) &amp;\to_{\beta} (\text{true} \;
M \; N)\\
  &amp;\to_{\beta} M\\
  (\text{if} \; \text{false} \; M \; N) &amp;\to_{\beta} (\text{false}
\; M \; N)\\
  &amp;\to_{\beta} N\\
\end{aligned}
$$</span></p>
<p>没有<span
class="math inline"><em>β</em></span>推演规则和<code>if</code>，<code>true</code>和<code>false</code>只是一堆无意义的符号，我们凭什么说<code>true</code>就代表逻辑正确呢。但是在有<span
class="math inline"><em>β</em></span>推演规则和<code>if</code>后，这个世界出现了分支判断的概念，<code>true</code>和逻辑正确产生了映射关系。</p>
<p>实际上，在λ演算中，数字<code>0</code>的定义和<code>false</code>是等价的：</p>
<p><span class="math display">$$
\begin{aligned}
  0 &amp;= (\lambda \; (f \; x) x) \\
  &amp;\to_{\alpha} (\lambda \; (x \; y) \; y) \\
  &amp;= \text{false}
\end{aligned}
$$</span></p>
<p>早期C语言甚至根本没有专门的布尔值类型，<code>if</code>会直接将<code>0</code>视作逻辑错误，将所有非零值视为逻辑正确。或者更进一步，我们可以说C语言里所有的类型都是数字类型（在其他语言里也是如此，毕竟底层都是0和1，不过C语言更容易看出来这一点）：</p>
<ol type="1">
<li>首先所有的基础类型<code>int</code>, <code>float</code>,
<code>char</code>, <code>int*</code>等都是不同位数的数值类型。</li>
<li>其次我们自己定义类型如<code>struct</code>,
<code>union</code>到最后也是也不过是基础类型的组合。</li>
</ol>
<p>那么我们为什么要创造出这些本来没有的概念，或者说名字。很简单，因为人脑很讨厌没有意义的东西，<code>struct.field</code>这种访问数据的方式肯定要比直接读取一段连续的内存要容易理解得多。所以我们可以说，世间万物本没有意义，是人类的解释赋予了它们意义。</p>
<h3 id="自指与y组合子">自指与Y组合子</h3>
<p>侯世达提出了一个“怪圈”的概念</p>
<blockquote>
<p>当你在此层级系统中似乎总是朝着一个方向（比如向上、向外）移动，但在经历了一系列步骤后，却惊奇地发现自己回到了起点。</p>
</blockquote>
<p>怪圈之所以能形成，核心动力来自于自指。也就是一个系统能够“谈论它自己”或“指向它自己”。</p>
<p><img
src="https://i.mji.rip/2025/12/08/0df492f3e3324c511b818edf370ba0dc.jpeg" /></p>
<p>这个自我指涉的怪圈极其稳定、极其复杂，以至于产生了一种幻觉——觉得自己是一个独立的、有意志的实体。这个实体就是“我”。</p>
<p>在我们的生活中也会有这样的体验。当你正在思考的时候，会察觉到“自己正在思考”这件事。佛家把那个正在察觉的东西称作“末那识”，即六识之后的第七识。</p>
<p>有编程经验的人不难联想到递归的概念。在程序语言领域，递归通常指一个函数在自己的定义里调用了自己。现代程序语言基本都支持递归特性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">mult</span>(<span class="params">m, n</span>):</span><br><span class="line">  <span class="keyword">if</span> m == <span class="number">1</span>:</span><br><span class="line">    <span class="keyword">return</span> n</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> n * mult(m - <span class="number">1</span>, n)</span><br></pre></td></tr></table></figure>
<p>但是在λ演算里，是没办法这么简单就搞定的，因为λ演算里并不能赋予一个东西“名字”。<code>x,y,z</code>仅仅是符号，它们除了代表这里有个东西存在以外不是任何别的什么。我们上面定义的<code>true,false,if</code>更像是宏，也就是字符串替换，只是为了减少文字量的缩写形式。如果你要展开一个自指的宏，那么你将会的到一个无穷无尽的表达式，这在λ演算里是不允许的。</p>
<p>但是这不代表λ演算就没办法做到递归，但是会麻烦很多。λ演算中有个工具叫作Y组合子，它的推导过程十分复杂，碍于篇幅不在此处讲解，以后我会另写一篇文章来推演。在这里，我们直接给出它的定义：</p>
<p><span class="math display">$$
\begin{aligned}
  Y =&amp; (\lambda \; (f) \\
  &amp; \quad (\lambda \; (x) \; (f \; (x \; x)))\\
  &amp; \quad (\lambda \; (x) \; (f \; (x \; x))))
\end{aligned}
$$</span></p>
<p>当我们将Y组合子应用到一个λ表达式上时，将会产生这样的效果：</p>
<p><span class="math display">$$
\begin{aligned}
  (Y \; M) \to_{\beta} (M \; (Y \; M))
\end{aligned}
$$</span></p>
<p>由此我们在λ演算的世界里创造了自指/递归/循环的概念。我们身体里的那个所谓的自我意识就是类似的存在。</p>
<h3 id="哥德尔不完备定理和停机问题">哥德尔不完备定理和停机问题</h3>
<p>哥德尔证明了在任何足够复杂的数理逻辑系统中，都存在一些“真”但“无法在系统内被证明”的命题。这就像人类有意识，但我们无法通过内省完全理解产生意识的大脑神经元结构。</p>
<p>我们的意识就像上个例子里的<span
class="math inline"><em>M</em></span>。在<span
class="math inline"><em>M</em></span>的内部有自指的结构，让我们能够认识到自己的存在。但是<span
class="math inline"><em>M</em></span>的内部没有任何关于<span
class="math inline"><em>Y</em></span>的信息，我们无法认知到那个促使自我产生的驱动力。我们在这个怪圈之中，所以我们看不清怪圈的全貌。</p>
<p>同样的，λ演算自身也存在着无法解决的问题，即著名的图灵停机问题。没有办法写出一个λ表达式，这个表达式能够判断其他λ表达式是否能够在有限步数的推演后停止，即无法再次应用<span
class="math inline"><em>β</em></span>推演规则。</p>
<h2 id="结语">结语</h2>
<p>生命和意识并非来自某种神秘的、形而上学的“灵魂”物质，而是来自无生命的物质在极度复杂的自指结构中涌现出的怪圈。我们就是那个画自己的手，是那个永恒缠绕的金带（Eternal
Golden Braid）。</p>

    </div>

    
    
    

      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2025/12/04/%E4%BD%9B%E5%AE%B6%E5%93%B2%E5%AD%A602%EF%BC%9A%E8%A7%89%E6%80%A7/" rel="prev" title="佛家哲学02：觉性">
      <i class="fa fa-chevron-left"></i> 佛家哲学02：觉性
    </a></div>
      <div class="post-nav-item"></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%89%8D%E8%A8%80"><span class="nav-number">1.</span> <span class="nav-text">前言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%CE%BB%E6%BC%94%E7%AE%97"><span class="nav-number">2.</span> <span class="nav-text">λ演算</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%CE%BB%E6%BC%94%E7%AE%97"><span class="nav-number">2.1.</span> <span class="nav-text">什么是λ演算</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%CE%BB%E6%BC%94%E7%AE%97%E6%8E%A8%E6%BC%94%E8%A7%84%E5%88%99"><span class="nav-number">2.2.</span> <span class="nav-text">λ演算推演规则</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%89%80%E8%B0%93%E6%84%8F%E8%AF%86"><span class="nav-number">3.</span> <span class="nav-text">所谓意识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%8C%E6%9E%84%E4%B8%8E%E8%A7%A3%E9%87%8A"><span class="nav-number">3.1.</span> <span class="nav-text">同构与解释</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%87%AA%E6%8C%87%E4%B8%8Ey%E7%BB%84%E5%90%88%E5%AD%90"><span class="nav-number">3.2.</span> <span class="nav-text">自指与Y组合子</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%93%A5%E5%BE%B7%E5%B0%94%E4%B8%8D%E5%AE%8C%E5%A4%87%E5%AE%9A%E7%90%86%E5%92%8C%E5%81%9C%E6%9C%BA%E9%97%AE%E9%A2%98"><span class="nav-number">3.3.</span> <span class="nav-text">哥德尔不完备定理和停机问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E8%AF%AD"><span class="nav-number">4.</span> <span class="nav-text">结语</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Zane.F</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">3</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2025</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zane.F</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
